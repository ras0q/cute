#!/bin/sh -eu

# MARK: - Helper Functions

_cute_rsep="\036"
_cute_usep="\037"

_cute_find_markdown_files() {
  local max_depth=$1
  if [ -z "$max_depth" ]; then
    echo "_cute_find_markdown_files: max_depth is required." > "/dev/stderr"
    return 1
  fi

  find . -maxdepth $max_depth -type f -name "*.md" -o -name "*.markdown" | sort
}

# Extract tasks from markdown files.
# Example: _cute_extract_tasks file0.md file1.md
# Output format: Name0<US>Slug0<US>Shell0<US>Command0<RS>Name1<US>Slug1<US>Shell1<US>Command1<RS>...
_cute_extract_tasks() {
  local files="$@"

  echo "$files" | xargs awk -v OFS="$_cute_usep" -v ORS="$_cute_rsep" '
    function slugify(str) {
      gsub(/[^a-zA-Z0-9]+/, "-", str)
      str = tolower(str)
      gsub(/^-+|-+$/, "", str)
      return str
    }
    match($0, /^```(sh|shell|bash|zsh)/, m) {
      if (shell_name != "") {
        print "_cute_extract_tasks: The previous codeblock is not closed." > "/dev/stderr";
        exit 1;
      }
      shell_name = (m[1] == "shell" ? "sh" : m[1]);
      next
    }
    /^```/ {
      if (task_name != "" && shell_name != "" && command != "") {
        slug = slugify(task_name);
        if (slug_seen[slug]++) {
          print "_cute_extract_tasks: Duplicate slug detected: " slug "\n" > "/dev/stderr";
          exit 1;
        }
        print task_name, slug, shell_name, command;
      }
      task_name = "";
      shell_name = "";
      command = "";
      next
    }
    /^\$/ {
      # Lines starting with "$" are considered as example command blocks,
      # representing command execution and its result, not as tasks to execute.
      if (shell_name != "") {
        task_name = "";
        shell_name = "";
        command = "";
      }
      next
    }
    shell_name != "" {
      command = command (command == "" ? "" : sep) $0 "\n";
      next
    }
    match($0, /^#{1,6} (.+)/, m) {
      task_name = m[1];
      next
    }
  '
}

# Find a task by name or slug.
# Example: _cute_find_task "$tasks" "Build"
# Output format: Name<US>Slug<US>Shell<US>Command
_cute_find_task() {
  local tasks="$1"
  local identifier="$2"

  echo "$tasks" | awk -F"$_cute_usep" -v RS="$_cute_rsep" -v id="$identifier" '
    $1 == id || $2 == id {
      print $0;
      exit 0;
    }
  '
}

# Decode a task string into its components.
# Example: _cute_decode_task "Build Project<US>build<US>sh<US>echo Hello" name slug shell command
# Sets variables: $name, $slug, $shell, $command
_cute_decode_task() {
  local task="$1"
  local __name_var="$2"
  local __slug_var="$3"
  local __shell_var="$4"
  local __command_var="$5"

  eval "$(echo "$task" | awk \
    -F"$_cute_usep" \
    -v RS="$_cute_rsep" \
    -v name_var="$__name_var" \
    -v slug_var="$__slug_var" \
    -v shell_var="$__shell_var" \
    -v command_var="$__command_var" '
    BEGIN { q = "\047" }
    {
      gsub(/\047/, "\047\\\047\047")
      printf "%s=%s%s%s;\n", name_var, q, $1, q
      printf "%s=%s%s%s;\n", slug_var, q, $2, q
      printf "%s=%s%s%s;\n", shell_var, q, $3, q
      printf "%s=%s%s", command_var, q, $4
      for(i=5; i<=NF; i++) {
        printf "\n%s", $i
      }
      printf "%s\n", q
    }
  ')"
}

# MARK: - Shell Completion

_cute_setup_completion() {
  local shell_type
  if [ -n "${ZSH_VERSION:-}" ]; then
    shell_type="zsh"
  elif [ -n "${BASH_VERSION:-}" ]; then
    shell_type="bash"
  else
    return 0
  fi

  case "$shell_type" in
    zsh)
      _cute_zsh_completion() {
        local tasks_output
        tasks_output=$(cute -l 2>/dev/null || true)
        local -a tasks
        tasks=$(cute -l 2>/dev/null | xargs -I {} echo '"{}"' | tr '\n' ' ')

        _arguments -C \
          '-h[Show help message]' \
          '-l[List tasks]' \
          '-L=[Limit search depth for Markdown files]:depth:' \
          '-v[Enable verbose mode]' \
          "*::task:(($tasks))"
      }

      compdef _cute_zsh_completion cute
      ;;
    bash)
      _cute_bash_completion() {
        local cur prev
        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"

        local tasks
        tasks=$(cute -l 2>/dev/null || true)

        # NOTE: eval wraps COMPREPLY=() to prevent fish from parsing bash-specific syntax
        case "$prev" in
          cute)
            eval 'COMPREPLY=($(compgen -W "-h -l -v $tasks" -- "$cur"))'
            ;;
          *)
            eval 'COMPREPLY=($(compgen -W "$tasks" -- "$cur"))'
            ;;
        esac
      }

      complete -o bashdefault -o default -o nospace -F _cute_bash_completion cute
      ;;
  esac
}

_cute_setup_completion

# MARK: - Main Function

_cute_usage() {
  cat <<EOF
Cute: A CLI tool that exeCUTEs commands from Markdown files.

Usage:
  cute [-h] [-l] [-v] [TASK_NAME|SLUG ...]

Options:
  -h: Show this help message and exit
  -l: List tasks
  -L: Limit search depth for Markdown files (default: 1)
  -v: Enable verbose mode

Arguments:
  TASK_NAME|SLUG: Task name or slug to execute. If specified, fuzzy search will be skipped.
                  Multiple tasks can be specified to execute them in order.

Example:
  cute -l                # List tasks
  cute build             # Execute task with slug "build"
  cute "Build Project"   # Execute task by name
  cute build test deploy # Execute multiple tasks in order
  cute \$(cute -l | fzf)  # Fuzzy search and execute a task using fzf
EOF
}

cute() {
  local cute_color_success="\033[32m"
  local cute_color_error="\033[31m"
  local cute_color_prompt="\033[90m"

  local cute_help_mode=0
  local cute_list_mode=0
  local cute_max_depth=1
  local cute_verbose_mode=0
  while getopts "hlL:v" opt; do
    case "$opt" in
      h) cute_help_mode=1 ;;
      l) cute_list_mode=1 ;;
      L) cute_max_depth="$OPTARG" ;;
      v) cute_verbose_mode=1 ;;
    esac
  done
  shift $((OPTIND - 1))

  cute_files="$(_cute_find_markdown_files "$cute_max_depth")" || return 1
  cute_tasks="$(_cute_extract_tasks "$cute_files")" || return 1

  _cute_list_tasks() {
    local awk_command
    if [ $cute_verbose_mode -eq 1 ]; then
      awk_command='{print $1, $2, $3, $4}'
    else
      awk_command='{print $2}'
    fi

    echo "$cute_tasks" | awk -F"$_cute_usep" -v RS="$_cute_rsep" -v OFS="\t" "$awk_command"
  }

  if [ $cute_list_mode -eq 1 ]; then
    _cute_list_tasks
    return 0
  fi

  if [ $cute_help_mode -eq 1 ] || [ $# -eq 0 ]; then
    _cute_usage
    printf "\nAvailable tasks:\n%s\n" "$(_cute_list_tasks | sed 's/^/  /')"
    return 0
  fi

  for cute_task_identifier in "$@"; do
    local cute_task=$(_cute_find_task "$cute_tasks" "$cute_task_identifier")
    if [ -z "$cute_task" ]; then
      echo "cute: Task not found: '$cute_task_identifier'"
      return 1
    fi

    _cute_decode_task \
      "$cute_task" \
      cute_task_name \
      cute_task_slug \
      cute_shell \
      cute_command
    if [ -z "$cute_task_name" ] || [ -z "$cute_task_slug" ] || [ -z "$cute_shell" ] || [ -z "$cute_command" ]; then
      echo "cute: Failed to decode task: '$cute_task_identifier'"
      return 1
    fi

    (
      if [ $cute_verbose_mode -eq 1 ]; then
        printf "${cute_color_success}▶ Executing task: %s\033[0m\n" "$cute_task_name"
      fi

      local cute_ps4="$(printf "${cute_color_prompt}[%s]$ \033[0m" "$cute_task_name")"
      local cute_task_exec="$cute_shell -c 'export PS4=\"$cute_ps4\"; set -ux; $cute_command'"
      eval "$cute_task_exec"

      local exit_code=$?
      if [ $exit_code -ne 0 ]; then
        return $exit_code
      fi

      if [ $cute_verbose_mode -eq 1 ]; then
        printf "${cute_color_success}✔ Completed task: %s\033[0m\n" "$cute_task_name"
      fi
    )
  done
}

